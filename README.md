# Порівняння ефективності жадібного алгоритму та алгоритму динамічного програмування

У цьому завданні ми порівнюємо два алгоритми для знаходження мінімальної кількості монет для заданої суми: жадібний алгоритм та алгоритм динамічного програмування. Обидва алгоритми мають свої переваги та недоліки, що стосуються їхньої ефективності та продуктивності при роботі з великими сумами.

### Жадібний алгоритм
Жадібний алгоритм намагається знайти рішення, вибираючи найбільші доступні монети на кожному кроці. Це робить його швидким, оскільки він має лінійну складність O(n), де n — кількість монетних номіналів. Проте жадібний алгоритм не завжди дає оптимальне рішення для всіх наборів номіналів монет. Він може бути ефективним, коли набір монет дозволяє завжди знайти оптимальне рішення, але в деяких випадках може не гарантувати мінімальної кількості монет.

### Алгоритм динамічного програмування
Алгоритм динамічного програмування забезпечує оптимальне рішення, використовуючи підхід заповнення таблиці для всіх можливих значень суми. Складність цього алгоритму — O(amount * n), де amount — сума, для якої потрібно знайти кількість монет, а n — кількість номіналів монет. Алгоритм може бути менш ефективним за часом виконання, особливо для великих значень суми, через необхідність обчислення для кожного значення, але він завжди знаходить оптимальне рішення.

### Порівняння продуктивності
На основі реальних результатів для суми 123456789, жадібний алгоритм показує значно кращий час виконання порівняно з алгоритмом динамічного програмування:

- **Час виконання жадібного алгоритму**: 0.000002 секунди
- **Кількість монет для жадібного алгоритму**: 2469139
- **Час виконання динамічного програмування**: 131.019793 секунди
- **Кількість монет для динамічного програмування**: 2469139

Жадібний алгоритм швидко знаходить рішення завдяки своїй лінійній складності, тоді як алгоритм динамічного програмування потребує значно більше часу для обчислень. Однак, обидва алгоритми в цьому випадку знайшли однакову кількість монет, що свідчить про те, що набір номіналів дозволяє жадібному алгоритму знайти оптимальне рішення.

Однак, хоча жадібний алгоритм швидший, він не завжди забезпечує оптимальне рішення для будь-яких наборів номіналів. Алгоритм динамічного програмування є повільнішим, але він гарантує мінімальну кількість монет для будь-якої суми.

### Висновки
- Жадібний алгоритм підходить для задач, де важлива швидкість, і набір монет забезпечує завжди оптимальне рішення.
- Алгоритм динамічного програмування підходить для ситуацій, коли необхідно гарантувати мінімальну кількість монет, особливо якщо набір монет не дозволяє жадібному алгоритму знайти оптимальне рішення.
- При великих сумах жадібний алгоритм виконується швидше, але його оптимальність залежить від набору монет. Динамічне програмування потребує більше часу, але є надійнішим для знаходження оптимального рішення.
